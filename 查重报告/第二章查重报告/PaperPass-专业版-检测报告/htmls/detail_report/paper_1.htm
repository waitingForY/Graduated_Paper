<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">1</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>node.js的事件驱动和非阻塞机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">2</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node. js从2009年诞生至今，已近经过了八年的发展，目前 node. js已经进入了青年时期，</span><span class='green'>在各大中小型 IT企业中的应用的十分广泛，尤其在 web领域，不论是前端 JS还是后端的 web服务器，</span><span class='green'>它都有用武之地。</span><a href='../sentence_detail/4/4.htm' target='right' class='orange' >Node.js不仅仅是一种编程语言，更是一种工具和平台，为JavaScript提供运行环境。</a><span class='green'>它封装了google的V8引擎，由于V8引擎在解释执行JavaScript的速度快，效率高等特点，再加上node.js本身对其进行了优化，这使得node.js的性能也非常好。</span><span class='green'>而底层的代码执行模块使利用C++编写的，同时底层通过libuv库来实现了对事件循环队列的处理，并将耗时较长的I/O请求交给liveio来处理，以此来提高运行效率。</span><span class='green'>Node.js的优秀性能主要体现在其优秀的系统架构上，图2-1 所展示的就是node.js的架构图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">3</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-1 node.js的系统架构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">4</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node. js底层的事件循环机制是利用 libuv来实现的， libuv是一种高性能的事件驱动程序库，</span><span class='green'>它屏蔽了因为平台不同而带来的差异，在 Windows平台中， node. js是直接利用 Windows下的 IOCP（ I/ O Completion Port）通常称为 I/ O完成端口来实现的，</span><span class='green'>在 IOCP的内部其实是利用了线程池的原理，这些线程是由 Windows系统内核自动管理，不需要我们手动加以管理。</span><a href='../sentence_detail/12/12.htm' target='right' class='orange' >而在Linux平台上，node.js都是通过自行实现的线程池来完成异步非阻塞I/O的。</a><span class='green'>而libuv就是起这样一个平台间的过渡角色，对外提供统一的API接口，图2-2 所展示的就是事件驱动策略。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">5</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-2 node.js的事件驱动策略</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">6</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node.js采用的是事件驱动，异步编程的模式。</span><span class='green'>事件驱动这个词，对于程序员来说并不陌生，比如在网络套接字编程中，当 socket有数据到来的时候，</span><span class='green'>就会触发我们之前所注册的 callback函数的执行，而 node. js所提供的绝大多数 API都是采用的这种编程模式。</span><span class='green'>下面就来详细阐述一下node.js的这种事件驱动编程模式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">7</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>我们可以与 apache服务器的原理相比较一下， apache服务器采用的是单进程、多线程模型，</span><span class='green'>而 node. js是单进程、单线程模型，它是通过事件驱动的方式来实现并发的，不会为每一个客户请求创建单独的线程，</span><span class='green'>而是通过事件监听器来判断，最后触发 callback函数的执行。</span><a href='../sentence_detail/22/22.htm' target='right' class='orange' >当 node. js的主线程运行的时候，就会创建一个事件队列（ event queue），</a><a href='../sentence_detail/23/23.htm' target='right' class='orange' >在这个队列中几乎保存了程序所需要的每一个 I/ O操作，由于线程会循环地去处理事件队列中的 I/ O操作，</a><span class='green'>该队列也被称为循环队列。</span><a href='../sentence_detail/25/25.htm' target='right' class='orange' >如果在程序的执行过程中，遇到了比如像文件的读写、数据库的查询等 I/ O操作来阻塞任务时，</a><span class='green'>线程不会停下来等待这些操作，而是注册一个 callback函数，转而继续执行队列中的下一个操作。</span><a href='../sentence_detail/27/27.htm' target='right' class='orange' >而这里的callback函数，只有在这些阻塞任务执行结束之后才会被线程调用。</a><span class='green'>在事件循环队列中，为了避免造成类似于递归调用的无限循环中，要求所有的callback函数都必须经过一个tick周期，在程序中的具体表现就是所有的callback函数都要执行process.nextTick()。</span><span class='green'>图2-3 所展示的就是node.js的事件驱动原理图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">8</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-3 node.js 的事件驱动原理图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">9</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>从图2-3 node. js的事件驱动原理图可以看出，在 node. js的应用中有读文件和查询数据看两种 I/ O操作，</span><span class='green'>该应用的主线程会创建一个事件循环队列，在这个循环队列中有文件的打开操作、读文件、连接数据库、查询数据库等操作。</span><span class='green'>比如应用在执行下面这样一段代码：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">10</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/34/34.htm' target='right' class='orange' >也就是在执行查询数据库操作是，程序的第二个参数就是一个回调函数，</a><span class='green'>当程序运行到这里的时候，由于 I/ O操作会消耗大量时间而不会立刻返回查询的结果，</span><a href='../sentence_detail/36/36.htm' target='right' class='orange' >而是将该事件插入事件队列中，转而继续执行下面的代码。</a><span class='green'>而当数据库查询操作返回后，就会将该事件发生到事件循环队列中，知道下一次循环监听到了该事件，就会触发回调函数的执行。</span><a href='../sentence_detail/38/38.htm' target='right' class='orange' >而整个事件循环队列中的任务都执行结束后，node.js应用才会终止。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">11</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/39/39.htm' target='right' class='orange' >对于node.js的异步I/O非阻塞机制也是建立在事件驱动机制之上的，对堵塞I/O的处理[16]，其底层是通过线程池来确保工作的正常执行。</a><span class='green'>node.js从线程池中取得一个线程来执行复杂任务，而不必占用主循环线程，这样就防止堵塞I/O占用空闲资源而造成效率下降。</span><span class='green'>在堵塞任务执行完毕后，通过查找到事件队列中相应的callback函数来处理接下来为完成的工作。</span><span class='green'>也就是说，对于那些相对耗时比较长的 I/ O操作，比如读写文件等，还有一些网络通信，</span><span class='green'>比如套接字， node. js会将这些操作交给一个称之为 worker threads的线程池去执行，当这些操作执行结束后，</span><a href='../sentence_detail/44/44.htm' target='right' class='orange' >通过事件通知，并执行回调函数，这就是异步 I/ O非阻塞机制。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">12</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>正因为node.js的这种事件驱动机制，使得那些十分耗时的I/O操作都可以异步执行，有效地解决了因为I/O操作而带来的性能和效率瓶颈问题。</span><span class='green'>在许多轻量级、高实时、高流量的应用系统中，都能见到node.js的身影。</span><span class='green'>本文中各个数据处理节点的设计和开发都是基于node.js的，同时前端可视化模块也是利用node.js的express框架进行开发的。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">13</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2 Node-red可视化流式处理框架</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">14</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.1 Node-red的概述</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">15</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node-red是IBM Emerging Technologies团队开发的一个可视化的数据流程编辑工具。</span><span class='green'>程序员可以直接通过 web浏览器就可以实现各种数据流程的编辑，同时可以实现对数据处理逻辑的编写，</span><span class='green'>Node- red把这些数据流程称为一个 flow，所编写的 flow可以以 json对象的形式保存为普通文件或者形成 js库，</span><span class='green'>方便用户分享、修改。</span><a href='../sentence_detail/54/54.htm' target='right' class='orange' >程序员在Node-red中可以通过组合各部件来编写应用程序，这些部件可以是硬件设备(如：</a><span class='green'>Arduino板子)、Web API(如：</span><span class='green'>WebSocket in和WebSocket out)、功能函数(如：</span><span class='green'>range)或者在线服务(如：</span><span class='green'>twitter)。</span><a href='../sentence_detail/59/59.htm' target='right' class='red' > Node- Red提供基于网页的编程环境，通过拖拽已定义 node到工作区并用线连接 node创建数据流来实现编程，</a><a href='../sentence_detail/60/60.htm' target='right' class='red' >程序员通过点击‘ Deploy’按钮实现一键保存并执行。</a><a href='../sentence_detail/61/61.htm' target='right' class='orange' > Node- red本身是基于 node. js开发的，它的执行模型和 node. js一样，也是通过事件驱动和非阻塞 I/ O机制来实现的，</a><span class='green'>这一点在上一节关于 node的事件驱动和非阻塞机制已经作了详尽的阐述。</span><a href='../sentence_detail/63/63.htm' target='right' class='red' >理论上，node.js的所有模块都可以被封装成Node-red的一个或几个节点（node）。</a><span class='green'>接下来，我们将详细地阐述如何搭建Node-red的环境，以及如何编写和管理自己的flow。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">16</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.2 Node-red的编译与安装</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">17</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于本文要对Node-red的原始节点进行补充，增加新的节点使其适合流式数据的传输和计算。</span><span class='green'>因此我们在安装Node-red的时候选择了源码安装。</span><span class='green'>安装的平台选择了Ubuntu14.04长期支持版。</span><span class='green'>具体的安装流程如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">18</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>依赖的安装：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">19</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于Node-red是基于Node.js的，所以在安装Node-red前必须先安装Node.js。</span><span class='green'>这里推荐使用源码安装。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">20</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在github上获取Node.js的源码：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">21</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>修改目录权限：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">22</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>使用./configure创建编译文件，并按如下命令安装：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">23</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>验证是否安装成功：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">24</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在按照上面三步安装之后，执行node -v命令之后，结果如图2-4 所示表示安装成功。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">25</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-4 node.js安装成功</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">26</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node-red的安装：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">27</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>因为我们要对Node-red的原始节点进行补充，所以这里我们必须选择源码安装。</span><span class='green'>安装Node-red是利用npm（NodePackagedModule）来安装，新版的node.js里面已经集成了npm，不需要另外单独安装，通过执行npm -v命令就可查看npm是否安装成功。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">28</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在github上获取Node-red的源码：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">29</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>安装Node-red：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">30</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>安装grunt-cli：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">31</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为了能够利用Node-red顺利的创建应用，这里我们还需要安装grunt-cli，并且不需要安装成全局模块。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">32</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>创建应用并运行Node-red：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">33</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>验证Node-red是否运行成功：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">34</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>按照上述步骤安装结束之后，如果执行node red命令之后，控制台出现如图2-5 所以表示安装成功：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">35</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-5 Node-red安装成功</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">36</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.3 Node-red的基本配置</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">37</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>安装好Node-red后，在Node-red的安装目录下有很多文件，从这些源码文件就可以看出Node-red的目录是十分清晰，各个模块的划分也是仅仅有条。</span><span class='green'>在这些文件当中，绝大部分文件用户都不需要关心，但是有几个重要文件需要尤其注意，</span><span class='green'>详细了解这些文件的作用和实用方法，对后面开发新节点有很重要的帮助，首先来了解一下 Node- red的目录结构，</span><span class='green'>图2-6展示了 Node- red的目录结构。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">38</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-6 Node-red目录结构图</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
