<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="paper_3.htm">下一页</a>
<a class="pagelink" href="paper_14.htm">尾页</a>
页码：2/14页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">22</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/104/104.htm' target='right' class='orange' >在国外， Yahoo推出了 S4流式数据处理系统，随后在2011年， Twitter也推出了自己的流式数据处理系统 Storm，</a><span class='green'>还有就是近年来开源社区新兴的 MOA（ Massive Online Analysis）、 Spark Stream都是流式处理系统，</span><a href='../sentence_detail/106/106.htm' target='right' class='orange' >这在一定程度上推动了流式数据处理的发展和应用。</a><a href='../sentence_detail/107/107.htm' target='right' class='orange' >但是像 S4、 Strom这样的流式数据处理系统在可伸缩性、容错性、数据吞吐量等方面存在着明显的不足，</a><span class='green'>而对于 MOA， Spark Stream这样的系统，虽然功能和 API十分丰富，但是在稳定性和易用性上不尽如人意。</span><a href='../sentence_detail/109/109.htm' target='right' class='orange' >所以，如果构建一个低延迟、高吞吐、易用且能持续可靠地运行的流式数据处理系统，是一个亟待解决的问题。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">23</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在国内，目前关于流式数据处理模型的研究还比较少，但目前国内主要有百度公司自主研发的Dstream和TM实时计算平台，在学术界主要是有一些关于流式数据挖掘算法的研究。</span><span class='green'>但是，流式数据的可视化分析已经在很多场景得到了应用，比如各大银行都陆续建立的大屏监控系统，</span><span class='green'>就是实时地监控银行的业务状况、系统运行状况、用户行为分析等，又比如政府网站群的监控，</span><a href='../sentence_detail/113/113.htm' target='right' class='orange' >也是通过实时监控网站的访问数据，分析用户的行为。</a><span class='green'>在这些应用的背后，如何建立一个高效、稳定、易于维护的实时处理模型显得尤为重要。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">24</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.2.2Node-red的研究应用现状</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">25</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node-red作为一种在物联网时代的新型产物，是一种用来快速搭建物联网应用程序的流式处理框架，在信息无处不在的时代，Node-red也越来越受到业界的关注和研究。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">26</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>它是由IBM Emerging Technologies团队发起的一个开源项目，其中Nick Leary 和Dave Conway-Jones工程师为Node-red的设计和开发做出了巨大的贡献。</span><span class='green'>2013年，Node-red以开源项目的形式被发布，经过短短几年的发展，Node-red已经拥有了一大批活跃的用户和开发人员。</span><span class='green'>Node-red依然是一个新型科技，时至今日，但凡用过Node-red的制造商、实验人员和一大批大大小小的公司，都已经见证了Node-red极具价值的应用之处。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">27</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在国外，IBM公司率先将Node-red应用起来，Node-red被集成到IBM公司的最新的云产品Bluemix上。</span><span class='green'>通过Bluemix提供的云服务，用Node-red来建立和管理一个实例（也就是一个应用流程），就可以实现消息的推送服务。</span><a href='../sentence_detail/122/122.htm' target='right' class='red' >Node-RED 的使用，与 Bluemix 中简单的 Push 服务相结合，使整个流程变得非常简单，需要调整的部分也少得多。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">28</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在国内，目前也有很多智能设备制造公司在使用 Node- red，可以很方便地通过 Node- red节点来控制硬件设备的状态，</span><span class='green'>比如拿 Node- RED搭配 Arduino，是一个快速原型化的好用工具，例如控制 RPI的某根管脚位去点亮 LED，</span><span class='green'>只要简单的拉四个节点，串一串再写一点程序代码即可做到。</span><span class='green'>因为Node-red还在进一步完善当中，原始开发的节点可能很难满足实际的需求，所以，我们在运用Node-red来管理数据流程的时候，还需要自己开发需要的功能节点。</span><span class='green'>在这一点上，目前在不少银行的业务监控系统中引入了Redis的访问节点。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">29</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.2.3Redis的研究应用现状</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">30</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis作为存储系统[11]之中的后起之秀，由于其数据结构丰富、基于内存计算、支持网络又可进行数据持久化等特点，迅速为许多企业和开发者所爱戴。</span><a href='../sentence_detail/130/130.htm' target='right' class='orange' >不论是在学术界还是在工业界，对Redis的研究都从未停止过。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">31</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis是由 Salvatore Sanfilippo为实时统计系统 LLOOGG量身定制的一个数据库，在2009年的时候将 Redis开源发布，</span><span class='green'>并开始于另外一位 Redis代码贡献者 Pieter Noordhuis一起继续 Redis的开发，直到现在，</span><span class='green'>Redis的代码托管在 GitHub上，并且开发也十分活跃。</span><span class='green'>随着Redis内存数据库的发布，经过短短几年的发展，Redis已经拥有了一大批活跃的用户和开发人员。</span><a href='../sentence_detail/135/135.htm' target='right' class='orange' >在国外，像GitHub、Viacom、Pinterest等都是Redis的用户，Github利用Redis集群，来统计用户项目的跟进状况。</a><span class='green'>而在国内，新浪在研究了 Redis数据库的源码后，搭建了有号称史上最大的 Redis集群，实现了</span><span class='green'>传统的 SQL数据库难以实现的计数分析（ counting）、反向缓存（ reverse cache）、 top10 list等功能。</span><span class='green'>近年来，也有不少银行，在自己的实时数据监控平台引入了 Redis数据库，实现了数据的实时处理和分析，</span><span class='green'>还有就是随着国家电子政务系统的逐渐推行，不少的地方政府也在自己的数据中心监控系统中引入了 Redis数据库，</span><span class='green'>来实现数据实时计算和处理。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">32</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.3 论文主要工作和研究内容</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">33</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本文对大数据背景下流式数据处理过程中所遇到的挑战和难题进行了研究分析，详细研究了 Node- red流式处理框架的编程模型和消息推送机制，</span><span class='green'>Redis数据库的实现原理及其基于内存计算的原理。</span><span class='green'>设计了一种新的基于Node-red的流式管理和Redis的内存计算的流式数据处理模型，并通过实现网站访问实时监控系统来验证了该模型的可行性。</span><span class='green'>主要工作内容如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">34</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/146/146.htm' target='right' class='orange' >（1）本文首先对当前实时流数据处理模型的研究应用现状以及 Node- red与 Redis的研究应用现状进行分析，</a><span class='green'>同时结合 node. js的事件驱动与非阻塞机制详细阐述 Node- red的消息推送原理。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">35</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）对Redis数据库做了深入研究。</span><span class='green'>因为在流式数据处理中，经常会遇到关于最大值，最小值，累计求和等指标的计算，而去重统计是计算这些指标的基础。</span><span class='green'>因此，本文通过分析Redis有序集合的源码，结合Skip List的基本原理，提出了基于Redis有序集合的去重统计方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">36</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（3）在研究分析了流式数据的特点和流式数据处理的基本原理后，结合 Node- red的编程模型和消息推送机制，</span><a href='../sentence_detail/152/152.htm' target='right' class='orange' >设计了一种新的基于 Node- red的流式管理和 Redis的内存计算的流式数据处理模型。</a><span class='green'>由于原始的 Node- red缺乏对 Redis数据库的访问节点以及 Redis的 pub/ sub节点，</span><span class='green'>重新设计了新的数据输入、输出节点以及数据处理函数节点（ function_ node），</span><span class='green'>并安装部署到 Node- red框架当中，实现数据的流式处理和数据流的管理。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">37</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（4）本文最后还将设计好的流式数据处理模型，应用到实际生产环境中加以验证。</span><span class='green'>使用该模型对某政府网站的访问流量数据进行实时监控分析，设计了一套实时数据监控系统，该系统包括了数据的实时采集、实时分析和处理，</span><a href='../sentence_detail/158/158.htm' target='right' class='orange' >以及最后的数据可视化展示，并对结果进行了有效性分析。</a><span class='green'>实现了从模型设计到模型应用的全过程。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">38</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>1.4 论文章节结构概述</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">39</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/161/161.htm' target='right' class='orange' >本论文共分为七章，其章节结构安排如下：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">40</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/162/162.htm' target='right' class='orange' >第一章，绪论，首先介绍了本论文的研究背景和意义，通过阅读大量相关文献和论文资料，总结了国内外流式数据处理模型的研究现状，以及Node-red、Redis的研究应用现状。</a><a href='../sentence_detail/163/163.htm' target='right' class='orange' >然后简单的介绍了本论文的主要研究内容和全文的章节结构安排。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">41</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第二章，实时流数据处理的理论基础和技术，本章详细介绍了 node. js的异步非阻塞模式与事件驱动机制，</span><span class='green'>这是进行 Node- red节点开发的理论基础，同时详细介绍了 Node- red可视化流式处理框架，</span><span class='green'>本章最后还介绍了关于 Redis数据库的实现原理和 Pub/ Sub机制。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">42</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第三章，基于 Redis有序集合的去重统计方法的研究，分析 Redis有序集合的底层源码，</span><span class='green'>结合 Skip List算法研究了 Redis有序集合在实时流数据处理中的去重统计方法。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">43</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第四章，基于 Node- red和 Redis的实时流数据处理模型的设计，本章首先对在实际场景中的流式数据处理应用做了详尽的需求分析，</span><span class='green'>然后对模型的总体架构做了详细设计，最后对于 Node- red中原本缺少的用于流式数据的输入和输出节点以及数据处理节点做了重新设计，</span><span class='green'>并将设计的各个节点重新部署到 Node- red框架当中，使其成为一个能够胜任流式数据处理的完整模型。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">44</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第五章，实时流数据处理模型在网站访问监控系统中的应用，本章主要是对设计的新模型加以应用，以此来验证模型的可行性与高性能。</span><span class='green'>为此设计了一个网站访问的实时监控系统，数据处理就用到了本文设计的流式数据处理模型，将数据处理的结果输出到前端页面做可视化展示。</span><a href='../sentence_detail/174/174.htm' target='right' class='orange' >本章详细阐述了系统的功能，各个功能模块的设计与实现。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">45</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第六章，系统测试与性能分析，这一章是整个模型以及应用系统的测试环节，主要是分析了模型对流式数据的处理能力并对设计的应用系统进行功能测试。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">46</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/176/176.htm' target='right' class='orange' >第七章，全文总结与展望，是对本论文的主要工作进行最后总结，并对后续工作做了一些说明。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">47</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/177/177.htm' target='right' class='orange' >实时流数据处理的基础理论和技术</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">48</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.1 node.js的事件驱动和非阻塞机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">49</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>node. js从2009年诞生至今，已近经过了八年的发展，目前 node. js已经进入了青年时期，</span><span class='green'>在各大中小型 IT企业中的应用的十分广泛，尤其在 web领域，不论是前端 JS还是后端的 web服务器，</span><span class='green'>它都有用武之地。</span><a href='../sentence_detail/182/182.htm' target='right' class='orange' >node.js不仅仅是一种编程语言，更是一种工具和平台，为JavaScript提供运行环境。</a><span class='green'>它封装了google的V8引擎，由于V8引擎解释执行JavaScript的速度快，效率高等特点，再加上node.js本身对其进行了优化，这使得node.js的性能也非常好。</span><span class='green'>而底层的代码执行模块使利用C++编写的，同时底层通过libuv库来实现了对事件循环队列的处理，并将耗时较长的I/O请求交给liveio来处理，以此来提高运行效率。</span><span class='green'>node.js的优秀性能主要体现在其优秀的系统架构上，图2-1 所展示的就是node.js的架构图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">50</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-1 node.js的系统架构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">51</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node.js底层的事件循环机制是利用libuv来实现的，libuv是一种高性能的事件驱动程序库，它屏蔽了因为平台不同而带来的差异。</span><span class='green'>在 Windows平台中， node. js是直接利用 Windows下的 IOCP（ I/ O Completion Port）通常称为 I/ O完成端口来实现的，</span><span class='green'>在 IOCP的内部其实是利用了线程池的原理，这些线程是由 Windows系统内核自动管理，</span><span class='green'>不需要我们手动加以管理。</span><a href='../sentence_detail/191/191.htm' target='right' class='orange' >而在Linux平台上，node.js都是通过自行实现的线程池来完成异步非阻塞I/O的。</a><span class='green'>而libuv就是起这样一个平台间的过渡角色，对外提供统一的API接口，图2-2 所展示的就是事件驱动策略。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">52</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-2 node.js的事件驱动策略</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">53</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node.js采用的是事件驱动，异步编程的模式。</span><span class='green'>事件驱动这个词，对于程序员来说并不陌生，比如在网络套接字编程中，当 socket有数据到来的时候，</span><span class='green'>就会触发我们之前所注册的 callback函数的执行，而 node. js所提供的绝大多数 API都是采用的这种编程模式。</span><span class='green'>下面就来详细阐述一下node.js的这种事件驱动编程模式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">54</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>我们可以与 apache服务器的原理相比较一下， apache服务器采用的是单进程、多线程模型，一个用户请求对应一个线程，</span><span class='green'>而 node. js是单进程、单线程模型，它是通过事件驱动的方式来实现并发的，不会为每一个客户请求创建单独的线程，</span><span class='green'>而是通过事件监听器来判断，最后触发 callback函数的执行。</span><a href='../sentence_detail/201/201.htm' target='right' class='orange' >当 node. js的主线程运行的时候，就会创建一个事件队列（ event queue），</a><a href='../sentence_detail/202/202.htm' target='right' class='orange' >在这个队列中几乎保存了程序所需要的每一个 I/ O操作，由于线程会循环地去处理事件队列中的 I/ O操作，</a><span class='green'>该队列也被称为循环队列。</span><a href='../sentence_detail/204/204.htm' target='right' class='orange' >如果在程序的执行过程中，遇到了比如像文件的读写、数据库的查询等 I/ O操作来阻塞任务时，</a><span class='green'>线程不会停下来等待这些操作，而是注册一个 callback函数，转而继续执行队列中的下一个操作。</span><span class='green'>而这里的callback函数，只有在这些阻塞任务执行结束之后通知主线程调用执行。</span><span class='green'>在事件循环队列中，为了避免造成类似于递归调用的无限循环中，要求所有的callback函数都必须经过一个tick周期，在程序中的具体表现就是所有的callback函数都要执行process.nextTick()。</span><span class='green'>图2-3 所展示的就是node.js的事件驱动原理图。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="paper_3.htm">下一页</a>
<a class="pagelink" href="paper_14.htm">尾页</a>
页码：2/14页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
