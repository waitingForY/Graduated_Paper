<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="#">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：2/2页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">29</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>创建应用并运行Node-red：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">30</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>验证Node-red是否运行成功：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">31</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>按照上述步骤安装结束之后，如果执行node red命令之后，控制台出现如图2-5 所以表示安装成功：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">32</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-5 Node-red安装成功</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">33</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.3 Node-red的基本配置</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">34</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>安装好Node-red后，在Node-red的安装目录下有很多文件，从这些源码文件就可以看出Node-red的目录是十分清晰，各个模块的划分也是仅仅有条。</span><span class='green'>在这些文件当中，绝大部分文件用户都不需要关心，但是有几个重要文件需要尤其注意，</span><span class='green'>详细了解这些文件的作用和实用方法，对后面开发新节点有很重要的帮助，首先来了解一下 Node- red的目录结构，</span><span class='green'>图2-6展示了 Node- red的目录结构。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">35</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-6 Node-red目录结构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">36</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>下面简单地介绍一下各个目录文件存储的内容和作用：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">37</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）在/public目录下是一些关于Node-red本身的静态文件，包括资源文件、css样式文件、以及前端页面的html文件；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">38</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）/node-modules目录下面是一些外部依赖库，也就是Node-red需要的一些Node.js模块。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">39</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（3）/red目录下面就是真正的Node-red代码，主要是一些核心api、事件驱动程序、服务器端主程序、系统设计程序以及Node-red的入口程序等。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">40</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（4）/test目录下面主要是放了一些用于测试的Node以及flow；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">41</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（5）/nodes目录是一个极其重要的目录，Node-red中所有的节点都是存放在这个目录下的，包括各个节点的html和js文件，本文中重新设计的数据节点也会放在这个目录下。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">42</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（6）settings.js文件是整个Node-red的系统配置文件，该文件描述了启动的参数细节、端口和ip设置以及各个启动目录的设置。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">43</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>了解了各个目录文件的作用之后，接下来阐述如何配置Node-red。</span><span class='green'>Node-red几乎所有的配置信息都记录在setting.js文件中，首先要清楚各个配置选项的功能作用，表2-1 展示了Node-red的常用配置选项极其作用。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">44</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>表2-1 Node-red常用配置选项说明</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">45</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>选项名默认值作用</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">46</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>uiPort1880指定Node-red网页的端口号</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">47</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>uiHost127.0.0.1指定Node-red网页的ip地址</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">48</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>debugMaxLength1000指定debug节点调试数据的最大显示长度</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">49</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>flowFilePrettytrue是否保存编写的flow</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">50</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>userDir安装目录指定flow保存的位置</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">51</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>functionGlobalContextundefined用于加载外部依赖，其值是json对象</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">52</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>.........</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">53</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>安装好Node-red后，按照表2-1 所示的配置选项说明进行配置，然后重新启动Node-red，就可以在浏览器中输入http:</span><span class='green'>//127.0.0.1:</span><a href='../sentence_detail/105/105.htm' target='right' class='orange' >1880，即可打开Node-red的可视化流程编辑界面。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">54</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4 基于内存计算的数据库Redis</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">55</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4.1 Redis数据库的概述</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">56</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis是一个key-value存储系统。</span><a href='../sentence_detail/109/109.htm' target='right' class='red' >和memcached类似，但Redis支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(有序集合)以及hash（哈希类型）。</a><a href='../sentence_detail/110/110.htm' target='right' class='red' >这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</a><span class='green'>在此基础上，Redis支持各种不同方式的排序。</span><a href='../sentence_detail/112/112.htm' target='right' class='red' >与memcached一样，为了保证效率，数据都是缓存在内存中[18]。</a><a href='../sentence_detail/113/113.htm' target='right' class='red' >不同的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave同步，也就是主从同步。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">57</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/114/114.htm' target='right' class='red' >与其他key-value存储系统相比，Redis有着更为复杂的数据结构并且提供对它们的原子性操作，这是一个不同于其他数据库的一大重要突破。</a><a href='../sentence_detail/115/115.htm' target='right' class='red' >Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</a><a href='../sentence_detail/116/116.htm' target='right' class='orange' >Redis运行在内存中，但是也可以持久化到本地磁盘中，所以在许多大数据应用场景下，当需要对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。</a><a href='../sentence_detail/117/117.htm' target='right' class='red' >在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。</a><a href='../sentence_detail/118/118.htm' target='right' class='red' >同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为它们并不需要进行随机访问。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">58</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4.2 Redis数据库的储存原理</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">59</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis存储机制分成两种Snapshot 和 AOF。</span><a href='../sentence_detail/121/121.htm' target='right' class='red' >无论是那种机制，Redis都是将数据存储在内存中。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">60</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Snapshot工作原理:</span><a href='../sentence_detail/123/123.htm' target='right' class='red' > 是将数据先存储在内存，然后当数据累计达到某些设定的阈值的时候，就会触发一次DUMP操作，将变化的数据一次性写入数据文件（RDB文件）。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">61</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>AOF 工作原理:</span><a href='../sentence_detail/125/125.htm' target='right' class='red' > 是将数据也是先存在内存，但是在存储的时候会使用调用fsync来完成对本次写操作的日志记录，这个日志揭露文件其实是一个基于Redis网络交互协议的文本文件。</a><a href='../sentence_detail/126/126.htm' target='right' class='red' >AOF调用fsync也不是说全部都是无阻塞的，在某些系统上可能出现fsync阻塞进程的情况，对于这种情况可以通过配置修改，但默认情况不要修改。</a><a href='../sentence_detail/127/127.htm' target='right' class='red' >AOF最关键的配置就是关于调用fsync追加日志文件的平率，有两种预设频率，每次记录进来都添加，每秒添加一次。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">62</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/128/128.htm' target='right' class='orange' >这两种存储策略各有优点，从性能上讲， Snapshot方式的性能明显要高于 AOF方式，因为前者是采用2进制方式存储数据，</a><a href='../sentence_detail/129/129.htm' target='right' class='red' >数据文件比较小，加载快速，存储的时候是按照配置中的 save策略来存储，每次都是聚合很多数据批量存储，</a><a href='../sentence_detail/130/130.htm' target='right' class='red' >写入的效率很高，而 AOF则一般都是工作在实时存储或者准实时模式下。</a><span class='green'>相对来说存储的频率高，效率却偏低。</span><a href='../sentence_detail/132/132.htm' target='right' class='red' >但是从数据安全性上来讲， AOF数据安全性高于 Snapshot存储，因为 Snapshot存储是基于累计批量的思想，也就是说在允许的情况下，</a><a href='../sentence_detail/133/133.htm' target='right' class='red' >累计的数据越多那么写入效率也就越高，但数据的累计是靠时间的积累完成的，那么如果在长时间数据不写入 RDB，</a><a href='../sentence_detail/134/134.htm' target='right' class='red' >但 Redis又遇到了崩溃，那么没有写入的数据就无法恢复了，但是 AOF方式偏偏相反，根据 AOF配置的存储频率的策略可以做到最少的数据丢失和较高的数据恢复能力。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">63</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.4.3 Redis数据库的pub与sub机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">64</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>pub/sub功能即publish/subscribe功能[21，22]。</span><a href='../sentence_detail/137/137.htm' target='right' class='red' >在基于事件的系统中，pub/sub是目前广泛使用的通信模型，它采用事件作为基本的通信机制，提供大规模系统所要求的松散耦合的交互模式：</a><a href='../sentence_detail/138/138.htm' target='right' class='red' >订阅者比如客户端以事件订阅的方式表达出它有兴趣接收的一个事件或一类事件，发布者比如服务器可以将订阅者兴趣的事件随时通知相关订阅者。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">65</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis数据库也支持 pub/ sub机制，本论文所设计的流式数据处理模型中，新引入了数据的输入节点也就是 redis的 subscribe节点，</span><a href='../sentence_detail/140/140.htm' target='right' class='orange' >以及数据的输出节点 publish节点，将这两个节点在采集数据的时候用。</a><a href='../sentence_detail/141/141.htm' target='right' class='orange' >订阅者可以订阅多个Channal[23]，而发布者可以通过Channel，向订阅者发送消息。</a><a href='../sentence_detail/142/142.htm' target='right' class='orange' >但是发布者所发的消息是异步的，不需要等待订阅者订阅，也不关心订阅者是否订阅，</a><span class='green'>简单地说就是订阅者只能收到发布者后续所发送到该 Channel上的消息，如果之前发送的消息没有接收，</span><span class='green'>那么也再也接收不到了，下面是 Redis数据库的发布订阅命令。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">66</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>PUBLISH：</span><span class='green'>向channel_test发布消息message。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">67</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>SUBSCRIBE：</span><span class='green'>订阅channel_test消息，会收到发布者所发送的messag消息。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">68</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.5 本章小结</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">69</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/150/150.htm' target='right' class='orange' >本章主要是对本论文的相关技术进行了介绍，首先对 node. js的事件驱动和非阻塞机制进行了详细阐述，</a><span class='green'>主要是为后面 Node- red的节点设计打下理论基础，然后再是对 Node- red进行了详细介绍，</span><span class='green'>最后还详细介绍了 Redis数据库的基本概念、存储原理以及发布/订阅机制。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="#">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：2/2页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
