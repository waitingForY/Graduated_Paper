<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">1</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.1 node.js的事件驱动和非阻塞机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">2</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/1/1.htm' target='right' class='orange' >与nginx的服务原理类似，node.js采用事件驱动[14，15]的运行方式。</a><a href='../sentence_detail/2/2.htm' target='right' class='orange' >众所周知， nginx采用的是多进程、单线程模型，但是 node. js是通过事件驱动的方式，当它在处理客户请求的时候无需为每一个请求创建额外的线程，</a><span class='green'>而是通过事件监听器来判断，触发 callback函数的执行。</span><a href='../sentence_detail/4/4.htm' target='right' class='red' >在事件驱动的模型当中，每一个 I/ O工作都被添加到事件队列中，线程循环地处理队列上的工作任务，</a><span class='green'>当在执行过程中遇到某一事件(如读取文件、查询数据库等操作)来阻塞任务时，线程不会停下来等待该事件，</span><a href='../sentence_detail/6/6.htm' target='right' class='red' >而是留下一个处理结果的 callback函数，转而继续执行队列中的下一个任务。</a><a href='../sentence_detail/7/7.htm' target='right' class='red' >这个传递到队列中的callback函数，只有在堵塞任务运行结束后才被线程调用。</a><span class='green'>图2-1 为node.js的事件驱动原理图。</span><span class='green'>图2-1 node.js 的事件驱动原理图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">3</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>从图2-1 node.js的事件驱动原理图可以看出，node.js开始启动的进程会创建一个事件循环队列。</span><a href='../sentence_detail/11/11.htm' target='right' class='red' >循环没执行一次就是一个tick周期，在每个tick周期中，node.js会从事件循环队列中查看是否有事件需要处理，如果有就取出事件并执行相关的callback函数。</a><a href='../sentence_detail/12/12.htm' target='right' class='red' >只有在事件队列事件所有都执行完毕，node.js应用就会终止。</a><span class='green'>node.js对堵塞I/O的处理[16]，其底层是通过线程池来确保工作的正常执行。</span><a href='../sentence_detail/14/14.htm' target='right' class='orange' >node.js从线程池中取得一个线程来执行复杂任务，而不必占用主循环线程，这样就防止堵塞I/O占用空闲资源而造成效率下降。</a><a href='../sentence_detail/15/15.htm' target='right' class='orange' >在堵塞任务执行完毕后，通过查找到事件队列中相应的callback函数来处理接下来为完成的工作。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">4</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/16/16.htm' target='right' class='orange' >众所周知， I/ O操作无疑是十分耗时的，当服务器端接收到大量的客户请求时，如果为每一个客户请求创建进程或线程，</a><a href='../sentence_detail/17/17.htm' target='right' class='red' >这无疑会增加额外的内存开销，同时也可能浪费更多的时间资源。</a><a href='../sentence_detail/18/18.htm' target='right' class='orange' >正因为node.js是事件驱动的，于是它可以使用事件循环机制来解决I/O操作带来的性能和效率瓶颈问题。</a><a href='../sentence_detail/19/19.htm' target='right' class='red' >在 node. js中，一个 I/ O操作通常会带有一个回调函数，当 I/ O操作完成并返回时，</a><a href='../sentence_detail/20/20.htm' target='right' class='red' >就会调用这个 callbacke函数，而主线程则继续执行接下来为完成的代码。</a><a href='../sentence_detail/21/21.htm' target='right' class='orange' >下面说明一下node.js异步非阻塞I/O的运行原理。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">5</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在 Windows平台上， node. js是直接利用 Windows下的 IOCP（ I/ O Completion Port）通常称为 I/ O完成端口来实现的，</span><span class='green'>在 IOCP的内部其实是利用了线程池的原理，这些线程是由 Windows系统内核自动管理，</span><span class='green'>不需要我们手动加以管理。</span><a href='../sentence_detail/25/25.htm' target='right' class='orange' >而在Linux平台上，node.js从v0.9.3版本以后，都是通过自行实现的线程池来完成异步非阻塞I/O的。</a><span class='green'>由于这种跨平台的差异性，node.js通过构建一个平台层架构libuv，来屏蔽平台的差异性，所有平台的兼容性问题都是由这一层来完成。</span><span class='green'>图2-2 就是node.js的异步执行架构图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">6</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-2 node.js的异步执行架构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">7</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/29/29.htm' target='right' class='orange' >以上就异步非塞模型和事件驱动机制进行了总结。</a><a href='../sentence_detail/30/30.htm' target='right' class='red' >而这个事件循环的机制并不仅仅是 node. js所独有的，并且 node. js的代码是单线程执行的，</a><span class='green'>在面对大量并发请求的时候， node. js是有着自己独特优势的，这种优势主要体现在 node. js的优秀的系统架构，</span><span class='green'>图2-3展示了 node. js的系统架构图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">8</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-3 node.js的系统架构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">9</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/34/34.htm' target='right' class='red' >从该架构图中可以看出， node. js的底层有一个模块负责维护线程池，当一个 I/ O请求发出的时候，</a><a href='../sentence_detail/35/35.htm' target='right' class='red' > node. js的底层线程创建模块将新建一个线程来处理请求，完成后再将结果交还给上层。</a><a href='../sentence_detail/36/36.htm' target='right' class='red' >那么，当有多个请求的时候， node. js的底层模块将利用尽可能少的线程来完成最多的任务，</a><a href='../sentence_detail/37/37.htm' target='right' class='red' >如果存在空闲的线程，它将继续被利用来做其他的事情，这对于前面说的针对每个请求开一个新的进程或线程而言，</a><span class='green'>无疑“聪明”许多，也更加高效了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">10</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2 Node-red可视化流式处理框架</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">11</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.1 Node-red的概述</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">12</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/41/41.htm' target='right' class='red' >Node-red是IBM公司开发的一个可视化的编程工具。</a><a href='../sentence_detail/42/42.htm' target='right' class='red' >它允许程序员通过组合各部件来编写应用程序。</a><span class='green'>这些部件可以是硬件设备(如：</span><span class='green'>Arduino板子)、Web API(如：</span><span class='green'>WebSocket in和WebSocket out)、功能函数(如：</span><span class='green'>range)或者在线服务(如：</span><span class='green'>twitter)。</span><a href='../sentence_detail/48/48.htm' target='right' class='red' >Node-Red提供基于网页的编程环境，通过拖拽已定义node到工作区并用线连接node创建数据流来实现编程。</a><a href='../sentence_detail/49/49.htm' target='right' class='red' >程序员通过点击‘Deploy’按钮实现一键保存并执行。</a><a href='../sentence_detail/50/50.htm' target='right' class='red' >程序以JSON字符串的格式保存，方便用户分享、修改。</a><a href='../sentence_detail/51/51.htm' target='right' class='orange' >Node-red基于node.js，它的执行模型和node.js一样，也是事件驱动非阻塞的，这一点在上一节关于node的事件驱动和非阻塞机制已经作了详尽的阐述。</a><a href='../sentence_detail/52/52.htm' target='right' class='red' >理论上，node.js的所有模块都可以被封装成Node-red的一个或几个节点（node）。</a><span class='green'>接下来，我们将详细地阐述如何搭建Node-red的环境，以及如何编写和管理自己的flow。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">13</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.2 Node-red的编译与安装</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">14</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于本文要对Node-red的原始节点进行补充，增加新的节点使其适合流式数据的传输和计算。</span><span class='green'>因此我们在安装Node-red的时候选择了源码安装。</span><span class='green'>安装的平台选择了Ubuntu14.04长期支持版。</span><span class='green'>具体的安装流程如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">15</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>依赖的安装：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">16</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于Node-red是基于Node.js的，所以在安装Node-red前必须先安装Node.js。</span><span class='green'>这里推荐使用源码安装。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">17</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在github上获取Node.js的源码：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">18</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>修改目录权限：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">19</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>使用./configure创建编译文件，并按如下命令安装：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">20</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>验证是否安装成功：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">21</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在按照上面三步安装之后，执行node -v命令之后，结果如图2-4 所示表示安装成功。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">22</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-4 node.js安装成功</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">23</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node-red的安装：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">24</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>因为我们要对Node-red的原始节点进行补充，所以这里我们必须选择源码安装。</span><span class='green'>安装Node-red是利用npm（NodePackagedModule）来安装，新版的node.js里面已经集成了npm，不需要另外单独安装，通过执行npm -v命令就可查看npm是否安装成功。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">25</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在github上获取Node-red的源码：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">26</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>安装Node-red：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">27</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>安装grunt-cli：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">28</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为了能够利用Node-red顺利的创建应用，这里我们还需要安装grunt-cli，并且不需要安装成全局模块。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
