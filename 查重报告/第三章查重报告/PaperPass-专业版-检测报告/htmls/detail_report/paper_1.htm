<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">1</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第四章 基于Redis有序集合的去重统计方法的研究</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">2</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>上一章详细阐述了基于 Node- red与 Redis的流式数据处理模型的设计，</span><span class='green'>在整个流式数据处理模型中， Redis作为数据交换和数据计算的中心， Redis的有序集合 zset被用来进行统计计算，</span><span class='green'>最重要的工作就是去重统计。</span><span class='green'>本章将从“跳表”Skip List的基本原理到zset的源码分析，详细阐述有序集合的去重统计的原理。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">3</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.1 Skip List基本原理</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">4</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Skip List是由William Pugh提出的一种基于并联链表的、随机化的数据结构。</span><a href='../sentence_detail/7/7.htm' target='right' class='orange' >Skip List的查找效率与二叉查找树的查找效率差不多，可以实现平均复杂度为 的插入、删除和查找操作。</a><span class='green'>一般而言，跳表是在有序的链表的基础上增加的额外的链接，这种链接方式的增加，</span><span class='green'>不是随便增加的而是以随机化的方式增加的，同时对随机函数也有要求，必须是以对数函数的方式产生，</span><a href='../sentence_detail/10/10.htm' target='right' class='orange' >所以在链表中的查找可以迅速地跳过部分链表，跳表也因此得名。</a><a href='../sentence_detail/11/11.htm' target='right' class='orange' >众所周知，对于有序链表的查找操作，其时间复杂度为，尽管真正插入与删除节点的操作的复杂度只有，</a><span class='green'>但是，这些操作都需要首先查找到节点的位置，换句话说，是查找拉低了有序链表的整体性能。</span><span class='green'>而Skip List采用“空间换时间”的设计思想，除了原始链表外还保存一些“跳跃”的链表，达到加速查找的效果。</span><a href='../sentence_detail/14/14.htm' target='right' class='red' >可以很好解决有序链表查找特定值的困难。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">5</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>接下来研究一下Skip List实现的原理，首先来认识一下Skip List。</span><span class='green'>因为，“跳表”是在有序链表的基础上做改进的，所以我们从认识有序链表开始研究Skip List。</span><span class='green'>图4-1 展示的就是一个有序链表的数据结构图（这里H表示链表头部，T表示链表尾部，不是有效节点）：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">6</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-1 有序链表结构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">7</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>现在假设要在该有序链表中查找value为7的节点，只能一步一步地从头到尾按照1-]2-]3...的顺序找下去，很明显查找效率是 。</span><a href='../sentence_detail/20/20.htm' target='right' class='orange' >如果是数组的话，可以利用二分查找，时间复杂度可以提高到 。</a><span class='green'>但是链表不支持随机访问，所以不能应用二分查找。</span><span class='green'>但是可以考虑把中间位置的节点保存下来，重新构成新的顺序链表，经过重构的链表如图4-2 所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">8</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-2 重构后的有序链表</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">9</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>毫无疑问，这是一种典型的以空间换时间的设计思想。</span><span class='green'>原始的顺序链表，经过重构后变成了三个顺序链表，从下到上将这三个链表编号为0、1、2，</span><span class='green'>不难发现，2号链表就是原始链表，1号链表就是原始链表的四等分节点构成的，</span><a href='../sentence_detail/27/27.htm' target='right' class='orange' >0号链表是原始链表的二等分节点构成的。</a><span class='green'>现在，再来查找value为7的节点则只需要如下三个步骤：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">10</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）初始的的搜索范围是(H，T)，在0号链表中与4进行比较，7]4，将搜索范围更新为(4，T)。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">11</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）在1号链表中与6进行比较，7]6，继续更新搜索范围(6，T)。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">12</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（3）在2号链表中与7进行比较，结果7=7，查找成功。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">13</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/32/32.htm' target='right' class='orange' >很明显，在Skip List中保存了二分查找的信息，以此来提高查找效率。</a><span class='green'>当然在具体的实现上，如果要开辟额外的空间来保存新链表的话，会造成空间的极大浪费。</span><span class='green'>由于是链表，可以利用链的性质，改进存储结构，改进后的Skip List的存储结构图4-3 所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">14</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-3 改进后的Skip List存储结构</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">15</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>前面所讨论的Skip List结构是一种比较理想的结构，实际的Skip List算法是一种随机算法，它非常依赖于所生产的随机函数。</span><span class='green'>当然对随机函数的要求也比较严格，不能简单的按照 的形式来生成随机数，而是必须要按照满足概率 的几何分布来构造随机函数。</span><span class='green'>可以设计出如下随机函数randLevel():</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">16</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>现在考虑 的情况，可能的返回值有0、1、2、3四种情况，他们各自出现的概率是：</span><span class='green'>、 、 、 。</span><span class='green'>也就是说，如果有16个元素的话，第零层预计有16个元素，第一层预计有8个元素，</span><span class='green'>第二层约有4个元素，第三层约有2个元素，从下向上每层元素数量大约会减少一半。</span><span class='green'>因此，Skip List适合自顶向下进行查找，理想情况下，每下降一层搜索的范围就会缩小一半，可以达到二分查找的效率，时间复杂度为 。</span><a href='../sentence_detail/44/44.htm' target='right' class='orange' >最坏的情况是当前节点从head移动到链表的尾部，时间复杂度为 。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">17</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2 redis有序集合zset的源码分析</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">18</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Redis的有序集合zset的底层数据结构就是通过Skip List来实现的，而没有采用hash和hashtable来实现，虽然hash可以实现快速的查找，但是无法保证有序。</span><span class='green'>在了解了Skip List的基本原理后，接下来通过分析redis的源码，详细阐述zset的实现。</span><span class='green'>Redis中的zset所使用的Skip List与William Pugh提出的基本一致，只是做了部分改进，主要有三个方面的改进。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">19</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）Redis中的Skip List可以有重复的分值score，这是为了支持有序集合中可能有多个元素具有相同的分值score这样的需求。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">20</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）在节点进行比较的时候，不仅仅比较他们的score，同时还要比较他们所关联的元素的value。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">21</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（3）在Skip List中每个节点还有一个前向指针，这就相当于在双向链表中的prev指针，通过这个指针，可以从表尾向表头进行遍历。</span><span class='green'>正因为有了这个改进，zset就支持一些逆向操作命令，比如zrevrange、zremrangebyscore等。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">22</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>redis的源码中，zset的Skip List的节点定义在redis.h头文件中，其具体定义如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">23</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>有了节点的定义，那么就该是Skip List的定义了，Skip List同样也是定义在redis.h头文件中的。</span><span class='green'>和定义链表的结构一样，需要头节点、尾节点，他们都是指向zskiplistNode 的指针，同时还需要定义节点的数量，目前跳表的最大层数。</span><span class='green'>下面就是zset的跳表定义：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">24</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/57/57.htm' target='right' class='orange' >其实，Redis的有序集合zset主要支持的编码方式有两种，一种是ZIPLIST方式，另一种是SKIPLIST方式。</a><span class='green'>其中ZIPLIST方式可以表示较小的有序集合，而SKIPLIST方式可以表示任意大小的有序集合。</span><span class='green'>如果zset当前使用的编码方式是ZIPLIST，只要满足下面两个条件之一就可以转换为SKIPLIST编码方式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">25</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/60/60.htm' target='right' class='orange' >（1）当新增加的字符串的长度超过了server.zset_max_ziplist_value的时候（默认值为64）。</a>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
