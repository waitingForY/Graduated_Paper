<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">1</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/0/0.htm' target='right' class='orange' >第二章 实时流数据处理的基础理论和技术</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">2</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.1 node.js的事件驱动和非阻塞机制</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">3</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>node. js从2009年诞生至今，已近经过了八年的发展，目前 node. js已经进入了青年时期，</span><span class='green'>在各大中小型 IT企业中的应用的十分广泛，尤其在 web领域，不论是前端 JS还是后端的 web服务器，</span><span class='green'>它都有用武之地。</span><a href='../sentence_detail/5/5.htm' target='right' class='orange' >node.js不仅仅是一种编程语言，更是一种工具和平台，为JavaScript提供运行环境。</a><span class='green'>它封装了google的V8引擎，由于V8引擎解释执行JavaScript的速度快，效率高等特点，再加上node.js本身对其进行了优化，这使得node.js的性能也非常好。</span><span class='green'>而底层的代码执行模块使利用C++编写的，同时底层通过libuv库来实现了对事件循环队列的处理，并将耗时较长的I/O请求交给liveio来处理，以此来提高运行效率。</span><span class='green'>node.js的优秀性能主要体现在其优秀的系统架构上，图2-1 所展示的就是node.js的架构图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">4</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-1 node.js的系统架构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">5</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node.js底层的事件循环机制是利用libuv来实现的，libuv是一种高性能的事件驱动程序库，它屏蔽了因为平台不同而带来的差异。</span><span class='green'>在 Windows平台中， node. js是直接利用 Windows下的 IOCP（ I/ O Completion Port）通常称为 I/ O完成端口来实现的，</span><span class='green'>在 IOCP的内部其实是利用了线程池的原理，这些线程是由 Windows系统内核自动管理，</span><span class='green'>不需要我们手动加以管理。</span><a href='../sentence_detail/14/14.htm' target='right' class='orange' >而在Linux平台上，node.js都是通过自行实现的线程池来完成异步非阻塞I/O的。</a><span class='green'>而libuv就是起这样一个平台间的过渡角色，对外提供统一的API接口，图2-2 所展示的就是事件驱动策略。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">6</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-2 node.js的事件驱动策略</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">7</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node.js采用的是事件驱动，异步编程的模式。</span><span class='green'>事件驱动这个词，对于程序员来说并不陌生，比如在网络套接字编程中，当 socket有数据到来的时候，</span><span class='green'>就会触发我们之前所注册的 callback函数的执行，而 node. js所提供的绝大多数 API都是采用的这种编程模式。</span><span class='green'>下面就来详细阐述一下node.js的这种事件驱动编程模式。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">8</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>我们可以与 apache服务器的原理相比较一下， apache服务器采用的是单进程、多线程模型，一个用户请求对应一个线程，</span><span class='green'>而 node. js是单进程、单线程模型，它是通过事件驱动的方式来实现并发的，不会为每一个客户请求创建单独的线程，</span><span class='green'>而是通过事件监听器来判断，最后触发 callback函数的执行。</span><a href='../sentence_detail/24/24.htm' target='right' class='orange' >当 node. js的主线程运行的时候，就会创建一个事件队列（ event queue），</a><a href='../sentence_detail/25/25.htm' target='right' class='orange' >在这个队列中几乎保存了程序所需要的每一个 I/ O操作，由于线程会循环地去处理事件队列中的 I/ O操作，</a><span class='green'>该队列也被称为循环队列。</span><a href='../sentence_detail/27/27.htm' target='right' class='orange' >如果在程序的执行过程中，遇到了比如像文件的读写、数据库的查询等 I/ O操作来阻塞任务时，</a><span class='green'>线程不会停下来等待这些操作，而是注册一个 callback函数，转而继续执行队列中的下一个操作。</span><span class='green'>而这里的callback函数，只有在这些阻塞任务执行结束之后通知主线程调用执行。</span><span class='green'>在事件循环队列中，为了避免造成类似于递归调用的无限循环中，要求所有的callback函数都必须经过一个tick周期，在程序中的具体表现就是所有的callback函数都要执行process.nextTick()。</span><span class='green'>图2-3 所展示的就是node.js的事件驱动原理图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">9</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-3 node.js 的事件驱动原理图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">10</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>从图2-3 node. js的事件驱动原理图可以看出，在 node. js的应用中有读文件和查询数据看两种 I/ O操作，</span><span class='green'>该应用的主线程会创建一个事件循环队列，在这个循环队列中有文件的打开操作、读文件、连接数据库、查询数据库等操作。</span><span class='green'>举一个实际的例子来说明，假如node.js在执行下面这样一段代码：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">11</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>程序的第二个参数就是一个回调函数，当程序运行到这里的时候，由于 I/ O操作会消耗大量时间而不会立刻返回查询的结果，</span><a href='../sentence_detail/37/37.htm' target='right' class='orange' >而是将该事件插入事件队列中，转而继续执行下面的代码。</a><span class='green'>而当数据库查询操作返回后，就会将该事件发送到事件循环队列中，直到下一次循环监听到了该事件，就会触发回调函数的执行。</span><a href='../sentence_detail/39/39.htm' target='right' class='orange' >而只有当整个事件循环队列中的任务都执行结束后，node.js应用才会终止。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">12</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/40/40.htm' target='right' class='orange' >对于node.js的异步I/O非阻塞机制也是建立在事件驱动机制之上的，对堵塞I/O的处理[16]，其底层是通过线程池来确保工作的正常执行。</a><span class='green'>node.js从线程池中取得一个线程来执行复杂任务，而不必占用主循环线程，这样就防止堵塞I/O占用空闲资源而造成效率下降。</span><span class='green'>在堵塞任务执行完毕后，通过查找到事件队列中相应的callback函数来处理接下来为完成的工作。</span><span class='green'>也就是说，对于那些相对耗时比较长的 I/ O操作，比如读写文件等，还有一些网络通信，</span><span class='green'>比如套接字， node. js会将这些操作交给一个称之为 worker threads的线程池去执行，当这些操作执行结束后，</span><a href='../sentence_detail/45/45.htm' target='right' class='orange' >通过事件通知，并执行回调函数，这就是异步 I/ O非阻塞机制。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">13</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>正因为node.js的这种事件驱动机制，使得那些十分耗时的I/O操作都可以异步执行，有效地解决了因为I/O操作而带来的性能和效率瓶颈问题。</span><span class='green'>在许多轻量级、高实时、高流量的应用系统中，都能见到node.js的身影。</span><span class='green'>本文中各个数据处理节点的设计和开发都是基于node.js的，同时前端可视化模块也是利用node.js的express框架进行开发的。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">14</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2 Node-red可视化流式处理框架</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">15</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.1 Node-red的概述</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">16</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Node-red是IBM Emerging Technologies团队开发的一个可视化的数据流程编辑工具。</span><span class='green'>程序员可以直接通过 web浏览器就可以实现各种数据流程的编辑，同时可以实现对数据处理逻辑的编写，</span><span class='green'>Node- red把这些数据流程称为一个 flow，所编写的 flow可以以 json对象的形式保存为普通文件或者形成 js库，</span><span class='green'>方便用户分享、修改。</span><a href='../sentence_detail/55/55.htm' target='right' class='orange' >程序员在Node-red中可以通过组合各部件来编写应用程序，这些部件可以是硬件设备(如：</a><span class='green'>Arduino板子)、Web API(如：</span><span class='green'>WebSocket in和WebSocket out)、功能函数(如：</span><span class='green'>range)或者在线服务(如：</span><span class='green'>twitter)。</span><a href='../sentence_detail/60/60.htm' target='right' class='red' > Node- Red提供基于网页的编程环境，通过拖拽已定义 node到工作区并用线连接 node创建数据流来实现编程，</a><a href='../sentence_detail/61/61.htm' target='right' class='red' >程序员通过点击‘ Deploy’按钮实现一键保存并执行。</a><a href='../sentence_detail/62/62.htm' target='right' class='orange' > Node- red本身是基于 node. js开发的，它的执行模型和 node. js一样，也是通过事件驱动和非阻塞 I/ O机制来实现的，</a><span class='green'>这一点在上一节关于 node的事件驱动和非阻塞机制已经作了详尽的阐述。</span><a href='../sentence_detail/64/64.htm' target='right' class='red' >理论上，node.js的所有模块都可以被封装成Node-red的一个或几个节点(node)。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">17</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本文所设计的实时流数据处理模型是通过利用Node-red来完成数据流程的管理以及处理数据的业务代码的编写两项工作。</span><span class='green'>接下来，详细阐述Node-red的编程模型以及它是如何管理数据流程。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">18</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.2 Node-red的编程模型</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">19</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本节我们通过介绍Node-red的一些关键概念和关键组件，并通过实际例子说明Node-red的编程模型。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">20</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）数据流程（flow），这是Node-red中最重要的一个概念，一个flow就是一个Node-red程序，它是多个节点连接在一起进行数据交换的集合。</span><span class='green'>在Node-red的底层，一个flow通常是由一系列的JavaScript对象和各个节点的配置信息组成，通过调用底层的node.js环境来执行JavaScript代码。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">21</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）节点（node），它是组成flow的最基本的元素，也是真正进行数据处理的载体。</span><span class='green'>当一个编写好的flow运行起来的时候，节点主要对从上游节点接收到的消息（简称message）进行处理，并产生新的消息传递给下游节点完成后续的处理工作。</span><a href='../sentence_detail/73/73.htm' target='right' class='orange' >一个Node-red的节点主要包括js文件这html文件，分别完成对节点功能的具体实现和节点UI设计。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">22</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（3）消息（message），它是节点之间进行传输的对象，也是数据的真正载体。</span><span class='green'>本质上消息是一个JavaScript对象，包含了各种对数据描述的属性。</span><span class='green'>消息是Node-red处理的最基本的数据结构，只有在节点被激活时消息才会被处理，再加上节点是相互独立的，这就保证了所有的数据流式互不影响且无状态。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">23</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（4）连线（wire），它是节点与节点之间的连接桥梁，它们通常将节点的输出端点连接到下游节点的输入端，表示由一个节点生成的消息应该由下一个连接节点处理。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">24</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在了解了这些基本的Node-red组件之后，下面通过举例说明Node-red的编程模型。</span><span class='green'>假设要实时发送一个消息到 debug节点，来测试消息在节点之间的传输，用到了一个定时器 timestamp节点，</span><span class='green'>一个函数节点 function_ node以及一个 debug节点，如图2-4所示。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">25</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-4 Node-red中的数据流程图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">26</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在图2-4所展示的 flow中 timestamp节点每隔两秒去触发 test function节点，执行其中的代码，</span><span class='green'>而 msg. payload是一个 debug节点，用于在 debug面板展示 test function处理过的数据。</span><span class='green'>这里仅仅是为了说明Node-red的编程模型，因此test function节点并没有复杂的数据处理逻辑，仅仅是返回一个hello world的消息，其实现代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">27</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在function节点的内部可以编写任何JavaScript函数，用于处理上游节点发送过来的数据。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">28</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>2.2.3 Node-red的基本配置</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">29</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于本文所设计的实时流数据处理模型，要对 Node- red的数据输入节点，输出节点以及数据处理节点进行重新设计，</span><span class='green'>同时新增 Redis数据的访问节点，因此，需要对 Node- red进行源码安装。</span><span class='green'>为了能够有效地利用Node-red进行流式数据处理和数据流程的管理，有必要阐述一下Node-red的基本配置。</span><span class='green'>经过源码安装后，Node-red的目录是十分清晰，各个模块的划分也是仅仅有条。</span><span class='green'>首先来了解一下Node-red的目录结构，图2-5展示了Node-red的目录结构。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">30</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图2-5 Node-red目录结构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">31</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>下面简单地介绍一下各个目录文件存储的内容和作用：</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="#">上一页</a>
<a class="pagelink" href="paper_2.htm">下一页</a>
<a class="pagelink" href="paper_2.htm">尾页</a>
页码：1/2页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
