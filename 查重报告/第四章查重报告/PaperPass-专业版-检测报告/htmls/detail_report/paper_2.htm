<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="paper_3.htm">下一页</a>
<a class="pagelink" href="paper_3.htm">尾页</a>
页码：2/3页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">29</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为了满足流式数据的输入需求，数据的输入节点的设计必须要满足一下几个原则：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">30</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）流式化数据，为了让成批到达的数据也能够在这样一个模型中得到计算，我们在设计数据输入节点的时候就要考虑到这点，也就是说让批量到达的数据逐条进入Node-red的flow。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">31</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）统一的数据格式，在一个数据处理模型中，数据格式的好与坏意味着后序进行数据计算的简与繁。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">32</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（3）高吞吐量，由于流式数据的产生是源源不断的，所以在设计输入节点的时候要充分考虑节点的数据吞吐量问题，</span><span class='green'>不然会造成大量数据的堆积，从而影响后续的数据分析与计算。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">33</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（4）高稳定性，输入节点是数据的入口，稳定性是必须考虑的一个因素。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">34</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（5）可移植性，为了能够将自己设计的数据输入节点共享给其他用户，节点的可移植性也十分重要。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">35</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为了设计出高效的适合流式数据传输的输入节点，考虑到流式数据的特点，结合redis数据库的sub机制，可以为Node-red新增一个redisSub节点。</span><span class='green'>从上一小节的总体架构图中我们可以看出，我们尽量让所有的数据通过 redis的发布订阅机制来进行收集，</span><span class='green'>把采集到的数据按类别放到不同的 redis通道（ channel）中，然后在 Node- red中通过我们新增加的 redisSub节点去订阅相应 channel的数据，</span><span class='green'>这样就可以把数据引入 Node- red中，完成了数据的接入工作。</span><span class='green'>同样redisSub节点也包括两个文件，一个是编写具体功能的实现代码的文件js文件，另一个是用于界面设计和帮助文档描述的html文件。</span><span class='green'>由于Node-red原始节点的存在，所以在进行文件命名标号的时候从52号开始，因为文件名编号和节点的ID是紧密相关的，所以节点的标号必须唯一。</span><span class='green'>设计好新的节点后需要重新安装部署新节点到 Node- red中，在利用 npm安装的时候，</span><span class='green'>Node- red的节点注册模块会去检测 setting. js配置文件，依次加载配置文件中的其他外部模块。</span><span class='green'>图3-3 是整个redisSub节点的设计图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">36</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-3 redisSub节点设计图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">37</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/85/85.htm' target='right' class='orange' >对于redisSub节点的界面ui设计，需要考虑有哪些信息需要用户输入该节点。</a><span class='green'>因为每个节点都有自己的名字，所以首先需要的一个信息就是用户为该节点取一个名字，需要用户输入Name字段。</span><span class='green'>由于数据是存放在redis server上的，所以还需要redisSub节点的描述redis server的ip地址和端口号。</span><span class='green'>当redisSub节点连接上redis server后，不知道数据是位于redis的哪一个channel上，因此还必须给出通道名称，这些都是redisSub节点所需要的最基本的信息。</span><span class='green'>另外还有就是redisSub节点的帮助信息也必须给出一定的说明。</span><span class='green'>ui界面主要是定义在52_redisSub.html文件中。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">38</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>而对于redisSub节点的具体功能，是在52_redisSub.js文件中实现的。</span><span class='green'>首先，要调用Node-red提供的节点创建函数createNode()创建一个节点，并把配置信息告诉节点。</span><a href='../sentence_detail/93/93.htm' target='right' class='orange' >节点接收到这些信息后，创建一个数据库连接池函数redisConnectionPool，将redis server的ip和port，和createNode函数内部所产生的uuid传递给连接池函数。</a><span class='green'>数据库连接池函数主要是通过一个 connections数组的_ nodeCount来记录有多少 redisSub节点连接 redis server，当有一个新节点连接 redis时，</span><span class='green'>该值就会加一，同样当有一个节点断开了解的时候就会减一。</span><span class='green'>当有close请求到的时候首先要判断_nodeCount的值是否为0，来决定是否删除connections对象数组。</span><a href='../sentence_detail/97/97.htm' target='right' class='orange' >关于redis数据库连接池函数的执行流程如图3-4 所示：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">39</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/98/98.htm' target='right' class='orange' >图3-4 Redis数据库连接池函数执行流程</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">40</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>有了数据库连接池函数，就可以来实现redisSub的功能了。</span><span class='green'>redisSub节点的前端页面将用户输入的redis server的信息保存起来，然后通过参数传给连接池函数连接redis server。</span><span class='green'>连接数据库后调用 client. subscribe()方法去订阅指定的通道，如果订阅成功，</span><span class='green'>就让 client去监听一个 message事件，看通道是否有数据发送过来，如果有数据就封装在 msg. payload中，</span><span class='green'>让 node的 send()方法发送出来，供下游节点接收。</span><span class='green'>与此同时，client还要去监听redis的close事件，当redisSub节点断开与redis server的连接的时候，就要调用redisConnectionPool.close()方法去断开连接。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">41</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>下面就是redisSub的功能函数的伪代码：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">42</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>3.3.2 数据输出节点的设计</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">43</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>数据进入Node-red后，经过各个计算节点的数据计算、封装等工作，然后打包成系统规定的数据格式后，需要从Node-red中输出，进入后续的数据可视化展示。</span><span class='green'>数据的输出就用到了Node-red的输出节点。</span><span class='green'>Node-red的输出节点允许把数据输出到Node-red的flow以外的其他服务和应用上去，对内有一个数据输入的左断点，对外暴露一个公共接口。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">44</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在Node-red中有一个常用的输出节点就是debug节点，这个节点是在编写flow的时候调试的时候用的，主要显示打印出数据经过上一节点处理之后的具体信息。</span><span class='green'>Debug节点是一个具有开关的节点，允许程序员手动开启或者禁用该节点。</span><span class='green'>debug节点的使用也非常简单，只需要在 Node- red左侧的节点栏中找到该节点然后拖拽到相应节点的后面，</span><span class='green'>并用线连接起来就可以实现数据的传输，最后开启 debug的启动按钮，部署了所编写的 flow后，</span><span class='green'>就可以在 Node- red的最右侧的 debug面板中看到打印出来的具体数据。</span><span class='green'>值得注意的是， debug节点的只有一个数据的入口，而没有数据的输出端，在设计 debug的时候，</span><span class='green'>重新封装了 sendDebug()函数，用来发送消息，将消息直接发送到 Node- red的网页编辑器 debug视图上直接显示，</span><span class='green'>而不是交由下游节点做数据处理。</span><a href='../sentence_detail/118/118.htm' target='right' class='orange' >下面给出debug节点的设计逻辑的部分伪代码。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">45</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>有了debug节点，可以方便用户在编写自己的flow的时候，及时查看数据的处理情况。</span><span class='green'>本文在第四章中应用该模型来解决实际问题的时候，将大量应用到debug节点。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">46</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为了保证数据的实时地输出到Node-red的flow以外的其他服务和应用上，这里我们新引入了redisPub节点。</span><span class='green'>顾名思义， redisPub节点就是将 redis的 publis功能嵌入到 Node- red中，通过设计一个新的节点来将经过 Node- red处理和计算过的数据输出来，</span><span class='green'>这里之所以选择 redis的 publis发布数据，一方面保证了数据的异步传输，另一方面也保证了数据的隔离（原因是各个 redis的通道数据是相互隔离的，</span><span class='green'>互补干预）。</span><span class='green'>在坚持节点的设计原则的前提下，图3-5 给出了redisPub的设计方案。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">47</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-5 redisPub节点设计图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">48</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>结合上一小节数据输入节点的设计可知， redisPub节点和 redisSub节点的设计恰好相反， redisPub节点只具有一个数据的输入接口，</span><span class='green'>也就是只有数据的输入端点，这一端是连接上一个数据处理节点的，在 redisPub节点中也必须定位 redis的位置，</span><a href='../sentence_detail/129/129.htm' target='right' class='orange' >也就是 redis服务器的 ip，端口号，不管是在 redis集群还是在单点的 redis服务器中都必须要指定，</a><span class='green'>同时还要指定数据输出到哪个 redis的 channel中。</span><span class='green'>所以redisPub节点的ui设计与redisSub节点的ui设计十分相识，不同的是他们的功能代码不一样，体现在js文件中。</span><span class='green'>图3-6 展示了redisPub节点的设计逻辑的具体流。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">49</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图3-6 RedisPub设计逻辑流程图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">50</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>同样，在实现redisPub节点的时候，也用到了数据库连接池函数，关于这个函数的设计思想在上一小节redisSub的设计中已经做了详细阐述。</span><span class='green'>从上面流程图可以看出，当 redisPub节点成功连接 redis后，将去监听 input事件，当有数据输入该节点后，</span><span class='green'>就会调用 this. client. publish()发布函数，将封装好的数据（ message对象）发布到指定的 channel上。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_1.htm">上一页</a>
<a class="pagelink" href="paper_3.htm">下一页</a>
<a class="pagelink" href="paper_3.htm">尾页</a>
页码：2/3页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2017 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
